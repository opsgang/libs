#!/bin/bash
# vim: et sr sw=4 ts=4 smartindent syntax=sh:
#
# TESTS for std/functions
#
### source_files()
EXPECTED_PREFIX="$(basename $0)"
EXPECTED_DEBUG_PREFIX="$(realpath -- $0)" # horrid, but no better way

t_source_files() {
    SUITE="source_files()"
    run_t will_error_if_file_can_not_be_sourced
    run_t can_source_multiple_files
}

### check_var_defined
t_check_var_defined() {
    SUITE="check_var_defined()"
    run_t non_empty_var_is_success
    run_t unset_var_is_error
    run_t empty_var_is_error
}

### required_vars()
t_required_vars() {
    SUITE="required_vars()"
    run_t success_if_all_vars_defined
    run_t error_if_any_vars_missing
}

### envsubst_tokens_list()
t_envsubst_tokens_list() {
    SUITE="envsubst_tokens_list"
    run_t create_list_of_tokens
}

### random_str()
# just make sure function exists - can't easily verify randomness!
t_random_str() {
    SUITE="random_str()"
    run_t check_random_str_func_exists
}

t_create_list_of_tokens() {
    local tokens="apple banana carrot"
    local expected='${apple} ${banana} ${carrot}'
    [[ "$(envsubst_tokens_list "$tokens")" == "$expected" ]]
}

t_check_random_str_func_exists() {
    declare -f random_str >/dev/null 2>&1
}

t_success_if_all_vars_defined() {
    local my_var1=apple my_var2=banana my_var3=carrot
    required_vars "my_var1 my_var2 my_var3"
}

t_error_if_any_vars_missing() {
    local my_var1=apple my_var2=carrot my_var5="egg-plant"
    ! required_vars "my_var1 my_var2 my_var3 my_var4 my_var5" 2>/dev/null
}

t_non_empty_var_is_success() {
    local my_var="a value"
    check_var_defined my_var
}

t_unset_var_is_error() {
    unset my_var_unset
    ! check_var_defined my_var_unset
}

t_empty_var_is_error() {
    local my_var_empty=""
    ! check_var_defined my_var_empty
}

t_can_source_multiple_files() {
    local rc=0 out=""
    local f="/var/tmp/t_will_error_if_file_can_not_be_sourced"
    echo "echo 'foo'">$f.1
    echo "echo 'bar'">$f.2
    out=$(source_files $f.1 $f.2 2>&1)
    echo $out | grep -Po '^foo bar$' >/dev/null || rc=1
    rm $f.1 $f.2
    return $rc
}

t_will_error_if_file_can_not_be_sourced() {
    local rc=0 out=""
    local f="/var/tmp/t_will_error_if_file_can_not_be_sourced"
    echo "echo 'foo'">$f.1
    echo "echo 'bar'">$f.2
    out=$(source_files $f.1 $f.2 $f.3 2>&1)
    echo "$out" | grep -P "... can not source $f.3" >/dev/null || rc=1
    [[ $out =~ ^foo.bar[^-_a-zA-Z0-9] ]] || rc=1
    rm $f.1 $f.2
    return $rc
}

### Tests for logging functions

### set_log_prefix()
# set_log_prefix() is intended to be called from i(), e(), d() etc
# Hence we need to amend which frame of the call stack to use for these
# tests that do call it directly (by setting FROM_STACKFRAME)
# so we get the EXPECTED_PREFIX or EXPECTED_DEBUG_PREFIX
t_set_log_prefix() {
    SUITE='set_log_prefix()'
    run_t prefix_when_run_from_script
    run_t prefix_when_run_in_shell
    run_t prefix_when_run_from_script_with_debug
    run_t prefix_when_run_in_subshell
    run_t prefix_when_run_in_sourced_file
}

### d()
t_d() {
    SUITE='d()'
    run_t no_output_if_DEBUG_not_set
    run_t output_if_debug_set
}

### __stacktrace()
t___stacktrace() {
    SUITE='__stacktrace'
    local patt="^t___stacktrace\(\) \(file: $0, line: \d+\).n..run_t\(\) \(file: [^,]+, line: \d+\).n"
    local st=$(FROM_STACKFRAME=0 __stacktrace)
    echo "$st" | grep -P "$patt" >/dev/null
}

# DEBUG output contains bash terminal codes for colour ...
t_output_if_debug_set() {
    echo "$(DEBUG=true d 'should print')" \
    | grep -Po "^DEBUG $EXPECTED_DEBUG_PREFIX:.*should print" >/dev/null
}

t_no_output_if_DEBUG_not_set() {
    [[ "$(unset DEBUG; d 'should not print')" == "" ]]
}

t_prefix_when_run_in_shell() {
    [[ $(bash -c ". $SRC && set_log_prefix") == "bash" ]]
}

t_prefix_when_run_from_script() {
    # Use FROM_STACKFRAME as we would not usually call set_log_prefix directly, but from a wrapper.
    local expected="$EXPECTED_PREFIX:t_prefix_when_run_from_script()"
    [[ "$(FROM_STACKFRAME=0 set_log_prefix)" == "$expected" ]]
}

t_prefix_when_run_from_script_with_debug() {
    # Use FROM_STACKFRAME as we would not usually call set_log_prefix directly, but from a wrapper.
    local expected="$EXPECTED_DEBUG_PREFIX:t_prefix_when_run_from_script_with_debug()"
    [[ "$(DEBUG=true FROM_STACKFRAME=0 set_log_prefix)" == "$expected" ]]
}

t_prefix_when_run_in_subshell() {
    local expected="$EXPECTED_DEBUG_PREFIX:t_prefix_when_run_in_subshell()"
    (
        (
            [[ $(DEBUG=true FROM_STACKFRAME=0 set_log_prefix) == "$expected" ]]
        )
    )
}

t_prefix_when_run_in_sourced_file() {
    local a=""
    (
        # no need to use FROM_STACKFRAME as set_log_prefix called indirectly within a new frame
        # created by anon file descriptor <()
        . <(echo -e 'a=$(DEBUG=true set_log_prefix)')
        [[ "$a" == "$EXPECTED_DEBUG_PREFIX:t_prefix_when_run_in_sourced_file()" ]]
    )
}

! . t/functions.t && echo "ERROR $0: could not source functions.t" && exit 1
source_src_and_deps || exit 1
run $*

