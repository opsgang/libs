#!/bin/bash
# vim: et sr sw=4 ts=4 smartindent syntax=sh:
#
# TESTS for std/functions
#
### source_files()
EXPECTED_PREFIX="$(basename $0)"
EXPECTED_DEBUG_PREFIX="$(realpath -- $0)" # horrid, but no better way

t_source_files() {
    SUITE="source_files()"
    run_t t_will_error_if_file_can_not_be_sourced
    run_t t_can_source_multiple_files
}

### check_var_defined
t_check_var_defined() {
    SUITE="check_var_defined()"
    run_t t_non_empty_var_is_success
    run_t t_unset_var_is_error
    run_t t_empty_var_is_error
}

### required_vars()
t_required_vars() {
    SUITE="required_vars()"
    run_t t_success_if_all_vars_defined
    run_t t_error_if_any_vars_missing
}

### envsubst_tokens_list()
t_envsubst_tokens_list() {
    SUITE="envsubst_tokens_list"
    run_t t_create_list_of_tokens
}

### random_str()
# just make sure function exists - can't easily verify randomness!
t_random_str() {
    SUITE="random_str()"
    run_t t_check_random_str_func_exists
}

### semver_a_ge_b()
t_semver_a_ge_b() {
    SUITE="semver_a_ge_b"
    run_t t_success_if_a_gt_b
    run_t t_success_if_a_eq_b
    run_t t_works_with_leading_v
    run_t t_works_with_leading_V
    run_t t_success_if_greater_prerel
    run_t t_fail_if_prerel
    run_t t_succeed_if_newer_prerel
    run_t t_succeed_if_newer_prerel_build
    run_t t_fail_if_a_lt_b
    run_t t_fail_if_a_not_semver
    run_t t_fail_if_b_not_semver
    run_t t_fail_if_b_is_empty
}

t_success_if_a_gt_b() {
    semver_a_ge_b "1.0.0" "0.1.0" \
    && semver_a_ge_b "11.0.0" "9.15.0"
}

t_success_if_a_eq_b() {
    semver_a_ge_b "1.0.0" "1.0.0"
}

t_works_with_leading_v() {
    semver_a_ge_b "v0.2.0" "V0.2.0"
}

t_works_with_leading_V() {
    semver_a_ge_b "V0.2.0" "v0.2.0"
}

t_success_if_greater_prerel() {
    semver_a_ge_b "0.2.1-alpha" "v0.2.0"
}

t_fail_if_prerel() {
    ! semver_a_ge_b "v0.2.1-alpha" "V0.2.1"
}

t_succeed_if_newer_prerel() {
    semver_a_ge_b "1.2.0-beta" "v1.2.0-alpha"
}

t_succeed_if_newer_prerel_build() {
    semver_a_ge_b "1.2.0-beta.10" "1.2.0-beta.1+1a"
}

t_fail_if_a_lt_b() {
    ! semver_a_ge_b "0.0.1000" "9.0.0"
}

t_fail_if_a_not_semver() {
    semver_a_ge_b "not-semver0.0.1000" "9.0.0" 2>/dev/null
    [[ $? -eq 2 ]]
}

t_fail_if_b_not_semver() {
    semver_a_ge_b "0.0.1" "not-semver-9.0.0" 2>/dev/null
    [[ $? -eq 2 ]]
}

t_fail_if_b_is_empty() {
    semver_a_ge_b "not-semver0.0.1000" "" 2>/dev/null
    [[ $? -eq 2 ]]
}

t_create_list_of_tokens() {
    local tokens="apple banana carrot"
    local expected='${apple} ${banana} ${carrot}'
    [[ "$(envsubst_tokens_list "$tokens")" == "$expected" ]]
}

t_check_random_str_func_exists() {
    declare -f random_str >/dev/null 2>&1
}

t_success_if_all_vars_defined() {
    local my_var1=apple my_var2=banana my_var3=carrot
    required_vars "my_var1 my_var2 my_var3"
}

t_error_if_any_vars_missing() {
    local my_var1=apple my_var2=carrot my_var5="egg-plant"
    ! required_vars "my_var1 my_var2 my_var3 my_var4 my_var5" 2>/dev/null
}

t_non_empty_var_is_success() {
    local my_var="a value"
    check_var_defined my_var
}

t_unset_var_is_error() {
    unset my_var_unset
    ! check_var_defined my_var_unset
}

t_empty_var_is_error() {
    local my_var_empty=""
    ! check_var_defined my_var_empty
}

t_can_source_multiple_files() {
    local rc=0 out=""
    local f="/var/tmp/t_will_error_if_file_can_not_be_sourced"
    echo "echo 'foo'">$f.1
    echo "echo 'bar'">$f.2
    out=$(source_files $f.1 $f.2 2>&1)
    echo $out | grep -Po '^foo bar$' >/dev/null || rc=1
    rm $f.1 $f.2
    return $rc
}

t_will_error_if_file_can_not_be_sourced() {
    local rc=0 out=""
    local f="/var/tmp/t_will_error_if_file_can_not_be_sourced"
    echo "echo 'foo'">$f.1
    echo "echo 'bar'">$f.2
    out=$(source_files $f.1 $f.2 $f.3 2>&1)
    echo "$out" | grep -P "... can not source $f.3" >/dev/null || rc=1
    [[ $out =~ ^foo.bar[^-_a-zA-Z0-9] ]] || rc=1
    rm $f.1 $f.2
    return $rc
}

### Tests for logging functions

### set_log_prefix()
# set_log_prefix() is intended to be called from i(), e(), d() etc
# Hence we need to amend which frame of the call stack to use for these
# tests that do call it directly (by setting FROM_STACKFRAME)
# so we get the EXPECTED_PREFIX or EXPECTED_DEBUG_PREFIX
t_set_log_prefix() {
    SUITE='set_log_prefix()'
    run_t t_prefix_when_run_from_script
    run_t t_prefix_when_run_in_shell
    run_t t_prefix_when_run_from_script_with_debug
    run_t t_prefix_when_run_in_subshell
    run_t t_prefix_when_run_in_sourced_file
}

### d()
t_d() {
    SUITE='d()'
    run_t t_no_output_if_DEBUG_not_set
    run_t t_output_if_debug_set
}

### __stacktrace()
t___stacktrace() {
    SUITE='__stacktrace'
    local patt="^t___stacktrace\(\) \(file: $0, line: \d+\).n..run_t\(\) \(file: [^,]+, line: \d+\).n"
    local st=$(FROM_STACKFRAME=0 __stacktrace)
    echo "$st" | grep -P "$patt" >/dev/null
}

# DEBUG output contains bash terminal codes for colour ...
t_output_if_debug_set() {
    echo "$(DEBUG=true d 'should print')" \
    | grep -Po "^DEBUG $EXPECTED_DEBUG_PREFIX:.*should print" >/dev/null
}

t_no_output_if_DEBUG_not_set() {
    [[ "$(unset DEBUG; d 'should not print')" == "" ]]
}

t_prefix_when_run_in_shell() {
    [[ $(bash -c ". $SRC && set_log_prefix") == "bash" ]]
}

t_prefix_when_run_from_script() {
    # Use FROM_STACKFRAME as we would not usually call set_log_prefix directly, but from a wrapper.
    local expected="$EXPECTED_PREFIX:t_prefix_when_run_from_script()"
    [[ "$(FROM_STACKFRAME=0 set_log_prefix)" == "$expected" ]]
}

t_prefix_when_run_from_script_with_debug() {
    # Use FROM_STACKFRAME as we would not usually call set_log_prefix directly, but from a wrapper.
    local expected="$EXPECTED_DEBUG_PREFIX:t_prefix_when_run_from_script_with_debug()"
    [[ "$(DEBUG=true FROM_STACKFRAME=0 set_log_prefix)" == "$expected" ]]
}

t_prefix_when_run_in_subshell() {
    local expected="$EXPECTED_DEBUG_PREFIX:t_prefix_when_run_in_subshell()"
    (
        (
            [[ $(DEBUG=true FROM_STACKFRAME=0 set_log_prefix) == "$expected" ]]
        )
    )
}

t_prefix_when_run_in_sourced_file() {
    local a=""
    (
        # no need to use FROM_STACKFRAME as set_log_prefix called indirectly within a new frame
        # created by anon file descriptor <()
        . <(echo -e 'a=$(DEBUG=true set_log_prefix)')
        [[ "$a" == "$EXPECTED_DEBUG_PREFIX:t_prefix_when_run_in_sourced_file()" ]]
    )
}

! . t/functions.t && echo "ERROR $0: could not source functions.t" && exit 1
source_src_and_deps || exit 1
run $*

