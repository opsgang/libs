# vim: et sr sw=4 ts=4 smartindent syntax=sh:
# ... these depend on std/functions and std/functions.log_msgs
#
GIT="${GIT:-git --no-pager}"
GIT_SHA_LEN=${GIT_SHA_LEN:-8}

# @desc checks a dir (defaults to current dir) for git changes.
# Returns 1 if there are uncommitted git changes.
# User can pass the dir path as an arg. If not, ./ is checked.
#
# @example
#   check_for_changes "/in/my/cloned/dir" || exit 1
#
check_for_changes() {
    local d="${1:-$(realpath ./)}"
    i "... checking for uncommitted changes in $d"
    [[ ! -z "${DEVMODE}" ]] && yellow_i "DEVMODE - skipping" && return 0;

    (
        ! cd $d 2>/dev/null && red_e "$d not a directory" && return 1;
        ! is_git_clone $d && red_e "$d is not a git dir" && return 1;
        if git diff-index --quiet HEAD --
        then
            i "... none found."
        else
            msg="... local changes in $d"
            msg="$msg\n... Commit them (tag the commit if wanted) then run this."
            red_e "$msg"
            exit 1
        fi
    ) || return 1
}

# @desc makes sure a git commit exists in the remote origin.
# Returns 1 if commit does not exist.
#
# Defaults to using the value of $GIT_SHA, or else the
# current dir's HEAD sha1.
#
# @example
#   # ... current dir's HEAD git sha1 exists in origin?
#   unset GIT_SHA; sha_in_origin || exit 1
#
#   # sha1 438704b exists in origin?
#   sha_in_origin 438704b || exit 1
#
#   # val of $GIT_SHA is in origin?
#   GIT_SHA=438704b sha_in_origin || exit 1
#
sha_in_origin() {
    local sha=${1:-${GIT_SHA:-$(git_sha)}}
    i "... checking git sha $sha exists in origin"

    if [[ -z "${sha}" ]]; then
        red_e "no git_sha passed as param, or \$GIT_SHA or sha of current dir."
        return 1
    fi

    [[ ! -z "${DEVMODE}" ]] && yellow_i "DEVMODE - skipping" && return 0

    (
        if ! git branch -r --contains ${sha} >/dev/null 2>&1
        then
            red_e "This commit ($sha) does not exist on origin."
            red_e "Did you push these changes?"
            exit 1
        else
            i "... all looking copacetic."
        fi
    ) || return 1
}

# @desc Tests whether a path is inside a git-cloned dir
# Returns 1 if not.
#
# User can pass path to test as arg. Defaults to current dir.
#
# @example
#
#   is_git_clone || exit 1 # current dir is in a git clone?
#
#   is_git_clone /my/project/file || exit 1 # is file inside a git clone?
#
is_git_clone() {
    local rc=0
    local d="${1:-$(realpath ./)}"
    (
        ! cd $d 2>/dev/null && e "could not cd to $d" && exit 1
        git --no-pager rev-parse --is-inside-work-tree >/dev/null 2>&1
    ) || rc=1
    return $rc
}

# @desc Prints branch name unless you've checked out a tag (prints from-a-tag).
# Returns 1 if current working dir is not in a git repo.
git_branch() {
    r=$(${GIT} rev-parse --abbrev-ref HEAD)
    [[ -z "$r" ]] && e "no rev to parse when finding branch?" && return 1
    [[ "$r" == "HEAD" ]] && r="from-a-tag"
    echo "$r"
}

# @desc Prints remote.origin.url from current dir's git config.
git_repo() {
    ${GIT} config remote.origin.url
}

# @desc Prints sha of current commit - up to $GIT\_SHA\_LEN chars.
git_sha() {
    ${GIT} rev-parse --short=${GIT_SHA_LEN} --verify HEAD
}

# @desc Prints out the git-tag on the current commit (exact match only)
git_tag() {
    ${GIT} describe --exact-match --tags 2>/dev/null
}

# @desc Prints user.name (from git config)
git_user() {
    ${GIT} config user.name
}

# @desc Prints user.email (from git config)
git_email() {
    ${GIT} config user.email
}

# @desc Prints user.name user.email (from git config)
git_id() {
    local u=$(git_user)
    local e=$(git_email)
    [[ -z "$u" ]] && echo "" && return 1
    echo $u $e
}

set_governance_vars_git() {

    git_vars || return 1

    if ! required_vars "GIT_REPO GIT_USER GIT_SHA"
    then
        e "... could not retrieve git info to use for governance"
        return 1
    fi

    git_info_vars

    return 0
}

# @desc `export` of `$GIT_INFO` - _sanitised_ str formed of repo, sha1, tag, branch info
# with special chars replaced with underscores.
#
# `$GIT_INFO` is suitable to use as an AWS tag value, or to consume in a shell script.
# Also exported is `$RAW_GIT_INFO` - the unsanitized version of the str.
#
# @example
#   GIT_REPO
git_info_vars() {

    required_vars "GIT_REPO GIT_SHA GIT_TAG GIT_BRANCH" || return 1

    export RAW_GIT_INFO="repo:${GIT_REPO} sha1:${GIT_SHA} tag:${GIT_TAG} branch:${GIT_BRANCH}"

    # ... sanitised string (suitable for unquoted val to var or aws tag value)
    export GIT_INFO=$(echo ${RAW_GIT_INFO} | tr -c '[[:alnum:] _.:/=+-@\n]' '_')
}

git_vars() {
    ! is_git_clone && e "... $PWD is not inside a git repo" && return 1

    export GIT_BRANCH="$(git_branch || echo 'NO_GIT_BRANCH')"
    export GIT_REPO="$(git_repo || echo 'NO_REMOTE')"
    export GIT_SHA="$(git_sha)"
    export GIT_TAG="$(git_tag || echo "NO_GIT_TAG")"
    export GIT_USER="$(git_user || echo "NO_GIT_USER")"
    export GIT_EMAIL="$(git_email || echo "NO_EMAIL")"
    export GIT_ID="$(git_id)" # git user and email, space separated

}

performed_by() {
    # ... if kicked off by ci tool, use BUILD_URL (works for circleci, jenkins, travis, shippable)
    [[ ! -z "${BUILD_URL}" ]] && echo "$BUILD_URL" && return 0

    # ... if run by an AWS instance or user
    if [[ ! -z "${AWS_PROFILE}${AWS_DEFAULT_PROFILE}${AWS_ACCESS_KEY_ID}" ]]; then
        id=$(aws iam get-user --query 'User.UserName' --output text 2>/dev/null)
        if [[ $? -ne 0 ]]; then
            id=$(aws sts get-caller-identity --query 'Arn' --output text 2>/dev/null)
        fi
        [[ ! -z "${id}" ]] && echo "$id" && return 0
    fi

    # ... finally, try to use git user from set_governance_vars_git
    id=${GIT_USER}
    [[ ! -z "${id}" ]] && echo "$id" && return 0

    e "performed_by(): unknown person triggered action - tried BUILD_URL, aws and git cfg"
    return 1
}
