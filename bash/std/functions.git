# vim: et sr sw=4 ts=4 smartindent syntax=sh:
#
# functions for:
# - getting metadata about sources or actors
#   e.g. git sha or user running script
# - ensuring we build or deploy from a known and repeatable version of source
#
GIT="${GIT:-git --no-pager}"
GIT_SHA_LEN=${GIT_SHA_LEN:-8}

check_for_changes() {
    local d="$1"
    i "... checking for uncommitted changes in $d"
    [[ ! -z "${DEVMODE}" ]] && yellow_i "DEVMODE - skipping" && return 0;

    (
        ! cd $d 2>/dev/null && red_e "$d not a directory" && return 1;
        if git diff-index --quiet HEAD --
        then
            i "... none found."
        else
            msg="... local changes in $d"
            msg="$msg\n... Commit them (tag the commit if wanted) then run this."
            red_e "$msg"
            exit 1
        fi
    ) || return 1
}

sha_in_origin() {
    local sha=${1:-${GIT_SHA:-$(git_sha)}}
    i "... checking git sha $sha exists in origin"

    if [[ -z "${sha}" ]]; then
        red_e "no git_sha passed as param, or \$GIT_SHA or sha of current dir."
        return 1
    fi

    [[ ! -z "${DEVMODE}" ]] && yellow_i "DEVMODE - skipping" && return 0

    (
        cd $SUPPORT_DIR ;
        if ! git branch -r --contains ${sha} >/dev/null 2>&1
        then
            red_e "This commit ($sha) does not exist on origin."
            red_e "Did you push these changes?"
            exit 1
        else
            i "... all looking copacetic."
        fi
    ) || return 1
}

in_git_clone() {
    if ! git --no-pager rev-parse --is-inside-work-tree >/dev/null 2>&1
    then
        return 1
    else
        return 0
    fi
}

set_governance_vars_git() {

    ! in_git_clone && e "... $(pwd) is not inside a git repo" && return 1

    export GIT_BRANCH="$(git_branch || echo 'NO_GIT_BRANCH')"
    export GIT_REPO="$(git_repo || echo 'NO_REMOTE')"
    export GIT_SHA="$(git_sha)"
    export GIT_TAG="$(git_tag || echo "NO_GIT_TAG")"
    export GIT_USER="$(git_user || echo "NO_GIT_USER")"
    export GIT_EMAIL="$(git_email || echo "NO_EMAIL")"
    export GIT_ID="$(git_id)" # 

    if ! required_vars "GIT_REPO GIT_USER GIT_SHA"
    then
        e "... could not retrieve git info to use for governance"
        return 1
    fi

    export RAW_GIT_INFO="repo:${GIT_REPO} sha1:${GIT_SHA} tag:${GIT_TAG} branch:${GIT_BRANCH}"

    # ... remove chars invalid in aws tag values from GIT_INFO
    export GIT_INFO=$(echo ${RAW_GIT_INFO} | tr -c '[[:alnum:] _.:/=+-@\n]' '_')
    return 0
}

git_branch() {
    r=$(${GIT} rev-parse --abbrev-ref HEAD)
    [[ -z "$r" ]] && e "no rev to parse when finding branch?" && return 1
    [[ "$r" == "HEAD" ]] && r="from-a-tag"
    echo "$r"
}

git_repo() {
    ${GIT} config remote.origin.url
}

git_sha() {
    ${GIT} rev-parse --short=${GIT_SHA_LEN} --verify HEAD
}

git_tag() {
    ${GIT} describe --exact-match --tags 2>/dev/null
}

git_user() {
    ${GIT} config user.name
}

git_email() {
    ${GIT} config user.email
}

git_id() {
    local u=$(git_user)
    local e=$(git_email)
    [[ -z $u ]] && echo "" && return 1
    echo $u $e
}

performed_by() {
    # ... if kicked off by ci tool, use BUILD_URL (works for circleci, jenkins, travis, shippable)
    [[ ! -z "${BUILD_URL}" ]] && echo "$BUILD_URL" && return 0

    # ... if run by an AWS instance or user
    if [[ ! -z "${AWS_PROFILE}${AWS_DEFAULT_PROFILE}${AWS_ACCESS_KEY_ID}" ]]; then
        id=$(aws iam get-user --query 'User.UserName' --output text 2>/dev/null)
        if [[ $? -ne 0 ]]; then
            id=$(aws sts get-caller-identity --query 'Arn' --output text 2>/dev/null)
        fi
        [[ ! -z "${id}" ]] && echo "$id" && return 0
    fi

    # ... finally, try to use git user from set_governance_vars_git
    id=${GIT_USER}
    [[ ! -z "${id}" ]] && echo "$id" && return 0

    e "performed_by(): unknown person triggered action - tried BUILD_URL, aws and git cfg"
    return 1
}
