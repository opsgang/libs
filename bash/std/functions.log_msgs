# vim: et sr sw=4 ts=4 smartindent syntax=sh:
# log msgs e() / i()

###################################
# GETTING THE CORRECT LOG PREFIX
###################################
#
# $FROM_STACKFRAME: use to adjust index of the call stack is used for the log prefix
#
# The default value of 1 will work for most things.
#
# However in an anon file descriptor for example
#   . <(echo ". functions.log_msgs; i 'fd means new frame'") # will not set the correct log prefix
#
# The anon file descriptor creates a new frame in the stack:
#   . <(echo ". functions.log_msgs; FROM_STACKFRAME=2 i 'fd means new frame'") # will set the prefix
#

# TERMINAL

__TBOLD="\033[1;37m"
__TDEBUG="\033[46;1;37m"
__TRED="\033[1;31m"
__TGREEN="\033[1;32m"
__TYELLOW="\033[1;33m"
__TBLUE="\033[1;34m"
__TRESET="\033[0m"

__CALLER_REGX="^([^ ]+) ([^ ]+) (.+)$"

# if running via bash or sh, use that as prefix,
# or
# if running via script, print executed or sourced
# file that called the logging function
#
# In DEBUG, prints full path to source files
set_log_prefix() {
    if [[ $0 =~ ^-?(ba)?sh$ ]]; then
        echo "${0#-}"
    else
        local src="" f="" func=""
        if [[ "$(caller ${FROM_STACKFRAME:-1})" =~ $__CALLER_REGX ]]; then
            src="${BASH_REMATCH[3]}"
            func_i=$(( $(( ${FROM_STACKFRAME:-1} + 1 )) ))
            func=${FUNCNAME[$func_i]}
        else
            src="$0"
        fi

        # ... if the cwd is changed, realpath may not work, so fall back to just $src
        f=$(realpath -- "$src" 2>/dev/null); [[ -z "$f" ]] && f=$src
        if [[ ! -z "$DEBUG" ]]; then
            str=$f
        else
            str=$(basename "$f")
        fi
        [[ ! -z "$func" ]] && str="$str:$func()"
        echo $str
    fi
}

e() {
    local IFS=''
    local pre="ERROR $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: $line" >&2
    done < <(echo -e "$*\n""TRACE:\n$(__stacktrace)")
}

i() {
    local IFS=''
    local pre="INFO $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: $line"
    done < <(echo -e "$*")
}

d() {
    [[ -z "$DEBUG" ]] && return 0
    local IFS=''
    local pre="DEBUG $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: ${__TDEBUG}$line${__TRESET}"
    done < <(echo -e "$*")
}

red_e() {
    local IFS=''
    local pre="ERROR $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: ${__TRED}$line${__TRESET}" >&2
    done < <(echo -e "$*\n""TRACE:\n$(__stacktrace)")
}

bold_i() {
    local IFS=''
    local pre="INFO $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: ${__TBOLD}$line${__TRESET}"
    done < <(echo -e "$*")
}

yellow_i() {
    local IFS=''
    local pre="INFO $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: ${__TYELLOW}$line${__TRESET}"
    done < <(echo -e "$*")
}

green_i() {
    local IFS=''
    local pre="INFO $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: ${__TGREEN}$line${__TRESET}"
    done < <(echo -e "$*")
}

blue_i() {
    local IFS=''
    local pre="INFO $(set_log_prefix)"
    while read line ; do
        echo -e "$pre: ${__TBLUE}$line${__TRESET}"
    done < <(echo -e "$*")
}

# __stacktrace()
# stacktrace should be called from a logging function
# e.g. e() or i(). This logging func will be index 0 when
# caller is invoked by __stacktrace().
# We're not interested in the logging function, so by default we choose
# index 1 (the thing that invoked the logging func).
#
# If you need to start from a different index, set
# $FROM_STACKFRAME in env to index num, before calling __stacktrace()
#
__stacktrace() {
    local start_index=${FROM_STACKFRAME:-1}
    local frame=$start_index str=""

    while true; do
        local st="" ln="" func="" file=""

        st=$(caller $frame) || break

        [[ "$st" =~ $__CALLER_REGX ]] \
        && ln="${BASH_REMATCH[1]}" \
        && func="${BASH_REMATCH[2]}" \
        && file="${BASH_REMATCH[3]}"

        local tmpl="%$(( $(( frame - $start_index )) * 2 ))s"
        local indent="$(printf $tmpl)"

        str_fmt="${indent}${func}() (file: $file, line: $ln)\n"
        str="$str$str_fmt"
        ((frame++))
    done
    echo "$str"
}

